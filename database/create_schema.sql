-- Create a new schema
CREATE SCHEMA ytkp;


-- Create the channel table
CREATE TABLE  ytkp.channel (
    channel_id SERIAL PRIMARY KEY,
    channel_url TEXT UNIQUE NOT NULL,
    channel_name TEXT UNIQUE NOT NULL,
    insert_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    scrape_date TIMESTAMP DEFAULT '1970-01-01 00:00:00' NOT NULL
);

-- Create functions for triggers in the channel table
CREATE FUNCTION ytkp.extract_channel_name_from_url() RETURNS TRIGGER AS $$
    BEGIN
        NEW.channel_name := RIGHT(NEW.channel_url, -24);
        RETURN NEW;
    END;
$$ LANGUAGE PLPGSQL;

-- Create triggers in the channel table
CREATE TRIGGER insert_channel_name
    BEFORE INSERT
    ON ytkp.channel
    FOR EACH ROW
    EXECUTE FUNCTION ytkp.extract_channel_name_from_url();

-- Add comments for the channel table and its columns
COMMENT ON TABLE ytkp.channel IS 'Table containing channel information';
COMMENT ON COLUMN ytkp.channel.channel_id IS 'Unique identifier for each channel, auto-incremented';
COMMENT ON COLUMN ytkp.channel.channel_url IS 'URL of the channel, must be provided';
COMMENT ON COLUMN ytkp.channel.channel_name IS 'Name of the channel, derived from the channel_url';
COMMENT ON COLUMN ytkp.channel.insert_date IS 'Timestamp of row insertion';
COMMENT ON COLUMN ytkp.channel.scrape_date IS 'Timestamp of the last time the channel was scraped for video URLs';
-- Add comments for functions
COMMENT ON FUNCTION ytkp.extract_channel_name_from_url() IS 'Function for a trigger; Trim first 24 characters from video url to obtain channel name';
-- Add comments for triggers
COMMENT ON TRIGGER insert_channel_name ON ytkp.channel IS 'Trigger to insert channel_name based on channel_url';


-- Create the video table
CREATE TABLE ytkp.video (
    video_id SERIAL PRIMARY KEY,
    video_yt_id TEXT UNIQUE NOT NULL,
    channel_id INT REFERENCES ytkp.channel(channel_id),
    video_avail TEXT,
    video_lang TEXT,
    video_url TEXT UNIQUE NOT NULL,
    video_name TEXT,
    video_description TEXT,
    upload_date DATE,
    insert_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    scrape_date TIMESTAMP DEFAULT '1970-01-01 00:00:00' NOT NULL
);

-- Create triggers for the video table
CREATE FUNCTION ytkp.extract_vid_id_from_url() RETURNS TRIGGER AS $$
    BEGIN
        NEW.video_yt_id := RIGHT(NEW.video_url, 11);
        RETURN NEW;
    END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER insert_yt_id
    BEFORE INSERT
    ON ytkp.video
    FOR EACH ROW
    EXECUTE FUNCTION ytkp.extract_vid_id_from_url();

-- Create functions for the video table
CREATE FUNCTION ytkp.find_channel_id(_channel_name TEXT) RETURNS INT AS $$
    DECLARE
        _channel_id INT;
    BEGIN
        SELECT channel_id INTO _channel_id
        FROM ytkp.channel
        WHERE channel_name = _channel_name;

        IF NOT FOUND THEN
            RETURN NULL;
        END IF;

        RETURN _channel_id;
    END;
$$ LANGUAGE plpgsql;

-- Add comments for the video table and its columns
COMMENT ON TABLE ytkp.video IS 'Table containing video information';
COMMENT ON COLUMN ytkp.video.video_id IS 'Unique identifier for each video, auto-incremented';
COMMENT ON COLUMN ytkp.video.video_yt_id IS 'Unique identifier for each video generated by YouTube';
COMMENT ON COLUMN ytkp.video.channel_id IS 'Foreign key referencing the associated channel';
COMMENT ON COLUMN ytkp.video.video_avail IS 'Availability status of the video - it might be used to download videos that arent public no more';
COMMENT ON COLUMN ytkp.video.video_lang IS 'Language of the video - it might be used to swap embedding models';
COMMENT ON COLUMN ytkp.video.video_url IS 'URL of the video, must be provided';
COMMENT ON COLUMN ytkp.video.video_name IS 'Name of the video';
COMMENT ON COLUMN ytkp.video.video_description IS 'Description of the video';
COMMENT ON COLUMN ytkp.video.upload_date IS 'Original upload date of the video';
COMMENT ON COLUMN ytkp.video.insert_date IS 'Timestamp of row insertion';
COMMENT ON COLUMN ytkp.video.scrape_date IS 'Timestamp of the last time the video was scraped for data (comments, description, transcript)';
-- Add comments for triggers
COMMENT ON FUNCTION ytkp.extract_vid_id_from_url() IS 'Function for a trigger; Extract last 11 characters from video url to obtain YouTube ID';
COMMENT ON TRIGGER insert_yt_id ON ytkp.video IS 'Trigger to insert video_yt_id based on video_url';
-- Add comments for functions
COMMENT ON FUNCTION ytkp.find_channel_id(_channel_name TEXT) IS 'Find the corresponding Channel ID based on channel_name';


-- Create the comment table
CREATE TABLE ytkp.comment_section (
    comment_id SERIAL PRIMARY KEY,
    comment_yt_id TEXT NOT NULL,
    comment_yt_parent TEXT NOT NULL,
    video_id INT REFERENCES ytkp.video(video_id),
    user_name TEXT,
    comment_text TEXT,
    like_count INT NOT NULL,
    is_verified BOOLEAN NOT NULL,
    is_favourited BOOLEAN NOT NULL,
    is_pinned BOOLEAN NOT NULL,
    comment_date TIMESTAMP NOT NULL,
    insert_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- Create functions for the comment_section table
CREATE FUNCTION ytkp.find_video_id(_video_yt_id TEXT) RETURNS INT AS $$
    DECLARE
        _video_id INT;
    BEGIN
        SELECT video_id INTO _video_id
        FROM ytkp.video
        WHERE video_yt_id = _video_yt_id;

        IF NOT FOUND THEN
            RETURN NULL;
        END IF;

        RETURN _video_id;
    END;
$$ LANGUAGE plpgsql;

-- Add comments for the comment table and its columns
COMMENT ON TABLE ytkp.comment_section IS 'Table containing comments on videos';
COMMENT ON COLUMN ytkp.comment_section.comment_id IS 'Unique identifier for each comment, auto-incremented';
COMMENT ON COLUMN ytkp.comment_section.comment_yt_id IS 'Comment ID generated by YouTube';
COMMENT ON COLUMN ytkp.comment_section.comment_yt_parent IS 'Comment ID generated by YouTube that this comment refers to';
COMMENT ON COLUMN ytkp.comment_section.video_id IS 'Foreign key referencing the associated video';
COMMENT ON COLUMN ytkp.comment_section.user_name IS 'Name of the user that wrote the given comment';
COMMENT ON COLUMN ytkp.comment_section.comment_text IS 'Text of the comment';
COMMENT ON COLUMN ytkp.comment_section.like_count IS 'Number of likes the comment has';
COMMENT ON COLUMN ytkp.comment_section.is_verified IS 'Flag if the author of the comment is verified';
COMMENT ON COLUMN ytkp.comment_section.is_favourited IS 'Flag if the comment is favourited by video author';
COMMENT ON COLUMN ytkp.comment_section.is_pinned IS 'Flag if the comment is pinned by video author';
COMMENT ON COLUMN ytkp.comment_section.comment_date IS 'Original submit date of the comment to YT service';
COMMENT ON COLUMN ytkp.comment_section.insert_date IS 'Date of insertion of the comment to the database';
-- Add comments for functions
COMMENT ON FUNCTION ytkp.find_video_id(_video_yt_id TEXT) IS 'Find the corresponding Video ID based on video_yt_id';


-- Create the video transcript table
CREATE TABLE ytkp.video_transcript (
    id SERIAL PRIMARY KEY,
    video_id INT REFERENCES ytkp.video(video_id),
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    transcript_text TEXT,
    is_sponsorblocked BOOLEAN DEFAULT false NOT NULL
);

-- Add comments on the transcript table and its columns
COMMENT ON TABLE ytkp.video_transcript IS 'Table containing transcripts of the videos as they appear in the transcript file (sliced into chunks with start and end times';
COMMENT ON COLUMN ytkp.video_transcript.id IS 'Unique identifier for each entry; not really used aside from being a PRIMARY KEY';
COMMENT ON COLUMN ytkp.video_transcript.video_id IS 'ID of the video that the transcript relates to';
COMMENT ON COLUMN ytkp.video_transcript.start_time IS 'Start time of the transcribed chunk';
COMMENT ON COLUMN ytkp.video_transcript.end_time IS 'End time of the transcribed chunk';
COMMENT ON COLUMN ytkp.video_transcript.transcript_text IS 'Transcript text chunk from VTT sub file';
COMMENT ON COLUMN ytkp.video_transcript.is_sponsorblocked IS 'Flag to differentiate sponsored chunks of the transcript and non-sponsored';


-- Create the sponsorblock timestamp table
CREATE TABLE ytkp.sponsorblock (
    id SERIAL PRIMARY KEY,
    video_id INT REFERENCES ytkp.video(video_id),
    start_time TIME NOT NULL,
    end_time TIME NOT NULL
);

-- Create triggers for the sponsorblock table
CREATE FUNCTION ytkp.update_sponsorblocked_chunks() RETURNS TRIGGER AS $$
    BEGIN
        UPDATE ytkp.video_transcript
        SET is_sponsorblocked = true
        WHERE 1=1
            AND end_time >= NEW.start_time
            AND start_time <= NEW.end_time;
        RETURN NEW;
    END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER insert_is_sponsorblocked
    AFTER INSERT
    ON ytkp.sponsorblock
    FOR EACH ROW
    EXECUTE FUNCTION ytkp.update_sponsorblocked_chunks();

-- Add comments for the sponsorblock table and its columns
COMMENT ON TABLE ytkp.sponsorblock IS 'Table containing information about sponsored (or otherwise useless) parts of the video';
COMMENT ON COLUMN ytkp.sponsorblock.id IS 'Unique identifier for each entry; not really used aside from being a PRIMARY KEY';
COMMENT ON COLUMN ytkp.sponsorblock.video_id IS 'ID of the video that has a sponsored part';
COMMENT ON COLUMN ytkp.sponsorblock.start_time IS 'Start time of the sponsored segment in the video';
COMMENT ON COLUMN ytkp.sponsorblock.end_time IS 'End time of the sponsored segment in the video';
-- Add comments for triggers
COMMENT ON FUNCTION ytkp.update_sponsorblocked_chunks() IS 'Function for a trigger; Set is_sponsorblocked flag into ytkp.video_transcript';
COMMENT ON TRIGGER insert_is_sponsorblocked ON ytkp.sponsorblock IS 'Trigger to set video_transcript.is_sponsorblocked flag when inserting into ytkp.sponsorblock';
